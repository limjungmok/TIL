#**소수 알고리즘. 에라토스테네스의 체**
1보다 큰 자연수 중에서, 양의 약수가 1과 자기 자신인 숫자를 의미한다.</br>

###**1. 흐름**

기존의 소수를 구하는 방식에서 수행속도를 눈에띄게 감소시킨 알고리즘</br>
2,3,4,5, ... 계속 배수를 지워주고,</br>
지워지지 않은 숫자들은 '소수'라고 판단하는 알고리즘이다.</br>

* 루트 N+1번까지만 배수를 지워줘도 소수 판별이 가능하다. 수행시간이 현저하게 줄어듬.<br>

###**2. 소스 코드**

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main(void){

    // 배열의 값이 1이면 소수
    // 배열의 값이 0 이면 소수가 아니다.
    // 소수는 2부터 존재한다.
    // 소수는 1과 자기자신 이외의 어떤 수로도 나누어지지 않는다.
    int arr[100];

    // 소수를 저장 할 배열 초기화
    for(int i=2; i<101; i++){
        arr[i] = 1; // 모든 수가 소수라고 처음에
    }

    // 각 배열값의 배수는 전부 소수가 아니기 때문에
    // (배수란 약수가 있다는 것인데, 즉 나눌 수 있다는것이 증명된다)
    // 배수들은 전부 소수가 아니라고 표시해준다.
    for(int i=2; i<101; i++){
        for(int j=i*2; j<101; j=j+i){
            arr[j] = 0;
        }
    }

    // 소수만 출력하자.
    for(int i=2; i<101; i++){
        if(arr[i] == 1) cout<<i<<" ";
    }
}
```
```java
public class Prime {
	public static void main(String[] args) {

		Integer[] arr = new Integer[101]; // 총 0 ~ 100 까지 100개의 배열을 셋

		for(int i=0; i<101; i++){ // 초기값을 1로 두며, 앞으로 0으로 셋팅하며 지워갈거다.
			arr[i] = 1;
		}

		for(int i=2; i<101; i++){	// 소수는 2부터니까, 2부터 100까지 체크한다.
			for(int j=i+i; j<101; j=j+i){	// 시작한 2의 배수부터 모두 0으로 체크해주는
				if(arr[j] == 0){			// 만약 0으로 체크되어있으면 넘어가
					continue;
				}else{
					arr[j] = 0;				// 체크가 되어있지 않다면 0으로 바꿔준다.
				}
			}
		}

		for(int i=2; i<101; i++){
			if(arr[i] == 1){				// 1은 곧 소수를 의미하며, 소수인 인덱스만 나열 해 준다.
				System.out.print(i+" ");
			}else{
				continue;
			}
		}
	}
}
```

###**3. 참고**

http://marobiana.tistory.com/91</br>
