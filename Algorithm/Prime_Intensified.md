#**소수 알고리즘. 에라토스테네스의 체**
1보다 큰 자연수 중에서, 양의 약수가 1과 자기 자신인 숫자를 의미한다.</br>

###**1. 흐름**

기존의 소수를 구하는 방식에서 수행속도를 눈에띄게 감소시킨 알고리즘</br>
2,3,4,5, ... 계속 배수를 지워주고,</br>
지워지지 않은 숫자들은 '소수'라고 판단하는 알고리즘이다.</br>

* 루트 N+1번까지만 배수를 지워줘도 소수 판별이 가능하다. 수행시간이 현저하게 줄어듬.<br>

###**2. 소스 코드**

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main(void){

    // 배열의 값이 1이면 소수
    // 배열의 값이 0 이면 소수가 아니다.
    // 소수는 2부터 존재한다.
    // 소수는 1과 자기자신 이외의 어떤 수로도 나누어지지 않는다.
    int arr[100];

    // 소수를 저장 할 배열 초기화
    for(int i=2; i<101; i++){
        arr[i] = 1; // 모든 수가 소수라고 처음에
    }

    // 각 배열값의 배수는 전부 소수가 아니기 때문에
    // (배수란 약수가 있다는 것인데, 즉 나눌 수 있다는것이 증명된다)
    // 배수들은 전부 소수가 아니라고 표시해준다.
    for(int i=2; i<101; i++){
        for(int j=i*2; j<101; j=j+i){
            arr[j] = 0;
        }
    }

    // 소수만 출력하자.
    for(int i=2; i<101; i++){
        if(arr[i] == 1) cout<<i<<" ";
    }
}
```
