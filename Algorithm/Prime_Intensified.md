#**소수 알고리즘. 에라토스테네스의 체**
1보다 큰 자연수 중에서, 양의 약수가 1과 자기 자신인 숫자를 의미한다.</br>

###**1. 흐름**

기존의 소수를 구하는 방식에서 수행속도를 눈에띄게 감소시킨 알고리즘</br>
2,3,4,5, ... 계속 배수를 지워주고,</br>
지워지지 않은 숫자들은 '소수'라고 판단하는 알고리즘이다.</br>

* 루트 N+1번까지만 배수를 지워줘도 소수 판별이 가능하다. 수행시간이 현저하게 줄어듬.<br>

###**2. 소스 코드**

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main(void){
    int n = 100;

    int arr[100];

    for(int i=2; i<n; i++){   // 전체 초기화 ( 1이면 소수, 0이면 소수가 아니다 )
        arr[i] = 1;
    }

    for(int i=2; i<n; i++){     // 2 ~ 100까지 검사를 한다.
        if(arr[i] == 0){        // 이미 소수가 아닌 값은 그대로 넘어가고
            continue;
        }
        for(int j=i*i; j<n+1; j=j+i){ // 각 인덱스의 배수들을 모두 지워준다.
            arr[j] = 0;               // 0으로 만듦으로써 소수가 아니라고 명시한다.
        }
    }

    for(int i=2; i<n; i++){           // 1은 소수가 아니므로, 출력 해 준다.
        if(arr[i] == 1){
            cout<<i<<" ";
        }else{
            continue;
        }
    }
}
```
